# Advertisement Platform

A platform for managing and targeting advertisements based on geolocation, biographical data, and user mood.

## Architecture

The application consists of two main components:

1. **Backend**: A Spring Boot application that provides REST APIs for managing advertisements and implementing targeting logic.
2. **Frontend**: A Next.js application that provides a user interface for managing advertisements and targeting.

## Prerequisites

- Docker and Docker Compose
- Java 21 (for local development)
- Node.js (for local development)

## Running with Docker Compose

The easiest way to run the application is using Docker Compose:

```bash
# Build and start the containers
docker-compose up -d

# View logs
docker-compose logs -f

# Stop the containers
docker-compose down
```

The application will be available at:
- Frontend: http://localhost:3000
- Backend API: http://localhost:8080/api
- H2 Database Console: http://localhost:8080/api/h2-console (JDBC URL: jdbc:h2:mem:addb, Username: sa, Password: password)

## Development Setup

### Backend (Spring Boot)

```bash
# Run the backend
./mvnw spring-boot:run
```

### Frontend (Next.js)

```bash
# Navigate to the frontend directory
cd frontend

# Install dependencies
npm install

# Run the development server
npm run dev
```

## IntelliJ IDEA Launchers

The project includes several run configurations for IntelliJ IDEA:

1. **AdPlatformApplication**: Runs the Spring Boot backend application.
2. **Frontend Dev**: Runs the Next.js frontend development server.
3. **Full Stack Application**: Compound configuration that runs both the backend and frontend together.
4. **Docker Compose**: Runs the application using Docker Compose.

To use these launchers:
1. Open the project in IntelliJ IDEA.
2. Select the desired run configuration from the dropdown menu in the top-right corner.
3. Click the green "Run" button or press Shift+F10.

## Features

- Create, read, update, and delete advertisements
- Target advertisements based on:
  - Geolocation (country, region, city, proximity)
  - Biographical data (age, gender, occupation, education, interests)
  - User mood and context (emotional state, time of day, day of week, season)
- Source advertisements from local storage or YouTube

## API Documentation

The backend provides the following REST APIs:

- `GET /api/advertisements`: Get all advertisements
- `GET /api/advertisements/active`: Get all active advertisements
- `GET /api/advertisements/{id}`: Get advertisement by ID
- `POST /api/advertisements`: Create a new advertisement
- `PUT /api/advertisements/{id}`: Update an existing advertisement
- `DELETE /api/advertisements/{id}`: Delete an advertisement
- `GET /api/advertisements/source/{source}`: Get advertisements by source
- `GET /api/advertisements/search?title={title}`: Search advertisements by title
- `POST /api/advertisements/targeted`: Get targeted advertisements based on user context
- `GET /api/advertisements/geo-targeted`: Get advertisements targeted by geolocation
- `GET /api/advertisements/mood-targeted`: Get advertisements targeted by mood


## Testing & Coverage

- Run tests and generate coverage with Maven:
  - `mvn clean verify`
- Coverage reports are generated by JaCoCo under `target/site/jacoco/index.html`.
- Boilerplate framework files (e.g., Spring Boot `*Application` and classes under `config` packages) are excluded from coverage to ensure meaningful metrics. See `docs/coverage.md` for details and rationale.

## Architecture Overview (Hexagonal/DDD)

This project follows Domain-Driven Design (DDD) and Hexagonal (Ports & Adapters) architecture to keep the domain model independent from frameworks and infrastructure concerns.

- Domain Layer (Core): Contains the domain model (entities, value objects), domain services, and domain events. It has no dependencies on framework or infrastructure code.
- Application Layer (Use Cases): Orchestrates use cases by coordinating domain objects. Defines input/output ports (interfaces) used by controllers and infrastructure adapters. Contains transactional and orchestration logic but no persistence or transport specifics.
- Adapters (Infrastructure & Delivery):
  - Driving adapters (e.g., REST controllers) call application ports to execute use cases.
  - Driven adapters (e.g., JPA repositories, cache, messaging) implement output ports to provide infrastructure capabilities.
- Configuration: Wires the adapters to the application and domain via Spring configuration, keeping boundaries explicit.

Benefits:
- Testability: Domain and application layers can be unit-tested without infrastructure.
- Replaceability: Adapters can be swapped (e.g., different DB, cache, or messaging) without changing core logic.
- Separation of Concerns: Clear boundaries reduce coupling and improve maintainability.

Testing Approach:
- Unit tests target domain and application services with test doubles for ports.
- Integration tests validate adapters (e.g., repository adapters, messaging) against real or embedded infrastructure.
- Architectural tests (ArchUnit) enforce hexagonal boundaries and layering rules.

Conventions used in this codebase:
- Packages reflect layers and bounded contexts.
- Controllers depend only on application ports, not on repositories.
- Repositories are adapters implementing output ports and are not used directly by controllers.
